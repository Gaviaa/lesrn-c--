
# 第二章 模板和IO

## 2.1-2.3是模板（函数模板、类模板）

### 函数模板

```cpp
template <class T, class X> // 让后面紧跟着的函数里有T不要报错，T代表泛型的数据类型，不是只能写T
void mySwap(T &a, X &b)     // 这是一个函数模板，
{
    T tmp = a;
    a = b;
    b = tmp;
}
```

普通模板和函数模板的区别：**普通函数可以进行隐式转换，函数模板不能进行隐式转换**，函数模板如果要进行隐式转换，必须加上**参数列表**

```cpp
void test()
{
    int a=10;
    int b=20;
    char c='a';
    myplus(a,c);
    myplus2<int>(a,c);//加上参数列表

}
```

### 类模板：将类中的数据类型参数化

类模板

```cpp
template<class T>
class Father
{
public:
    Father(T a)
    {
        this->a = a;
    } 
    void print()
    {
        cout << "a=" << a << endl;
    }
    T a;
};
```

普通类继承

```cpp
class Son :public Father<int>//必须指定父类模板参数
{
public:
    Son(int a):Father<int>(a)
    {
    }
    
};
```

类模板继承**重点**

```cpp
template<class T>
class Son2 :public Father<T>
{
public:
    Son2(T a):Father<T>(a)
    {
    }
   
};
```

类模板与函数模板区别：**类模板不会自动推导数据类型**

```cpp
Maker<sring,int> m("GAVIA",23);
```

类模板**分文件编写用.hpp**

## 2.4异常

### c++类型转换

#### 静态转换static_cast

静态转换：1.用于类层析结构中基类（父类）和派生类（子类）之间指针或引用的转换；2.基本数据类型的转换，注意字节大小

##### 基础类型转换

```cpp
void test1()
{
    char a = 'a';
    //char->double
    double b = static_cast<double>(a);//强制类型转换,static_cast<目标类型>(原始数据)
    cout << "b = " << b << endl;
}
```

##### 类的指针或引用转换

```cpp
//2.类指针或引用转换
class A
{
public:
    virtual void func()
    {
        cout << "A::func()" << endl;
    }
};
class B : public A
{
public:
    void func()
    {
        cout << "B::func()" << endl;
    }
    void func2()
    {
        cout << "B::func2()" << endl;
    }
};
//指针
void test2()
{
    A *a =new B;//父类指针指向子类对象
    B *b1 = static_cast<B *>(a);//父类指针转换为子类指针(向下，不安全)，static_cast<目标类型>(原始数据)，
    b1->func();
    b1->func2();
}
//引用
void test03()
{
    A a;
    B &b = static_cast<B &>(a);//父类引用转换为子类引用(向下，不安全)，static_cast<目标类型>(原始数据)，
    b.func();//打印出A::func()，因为引用是指向a的，a是A类的
    b.func2();
}
```

#### 动态转换dynamic_cast

动态转换；用于类层次间的上行转换和下行转换

```cpp
//动态转换
void test04()
{
    A *a = new B;//发生多态才可以向下转换
    B *b = dynamic_cast<B *>(a);//动态类型转换，只能用于指针或引用，dynamic_cast<目标类型>(原始数据)
    if (b == NULL)
    {
        cout << "转换失败" << endl;
    }
    else
    {
        b->func();
        b->func2();
    }
}
void test05(){
    B b1;
    A &a1 = dynamic_cast<A &>(b1);//动态类型转换，只能用于指针或引用，dynamic_cast<目标类型>(原始数据)
    a1.func();
}
```

#### 常量转换const_cast

常量转换:将常量指针或引用转换为非常量，并且仍然指向原来的对象，去除const属性（不可修改）

```cpp
//常量转换
void test06(){
    const int a = 10;
    //int *p = &a;//error
    int *p = const_cast<int *>(&a);//去掉常量性，const_cast<目标类型>(原始数据)
    *p = 20;
    cout << "a = " << a << endl;
    cout << "*p = " << *p << endl;
}
```

#### 重新解释转换reinterpret_cast(不安全)

可以将一个int类型，转换为指针或引用，没有关系的其他类指针也可以转换

```cpp
//重新解释转换
void test07(){
    int a = 10;
    double &b = reinterpret_cast<double &>(a);//重新解释转换，reinterpret_cast<目标类型>(原始数据)
    int &c = reinterpret_cast<int &>(a);

    cout << "b = " << b << endl;
    cout << "c = " << c << endl;
}
```

### 异常的基本语法和流程

异常处理就是程序在运行时检测到的错误，这些错误会导致程序崩溃。**异常处理是一种在程序运行时检测到的错误，并采取适当的措施来解决这些错误的方法。**

#### 基本语法

3个步骤：1->2->3

```cpp
int func(int a,int b)
{
    if(b==0)
    {
        throw 10;//1.抛出异常
    }
    return a/b;
}
void test()
{
    int a=5;
    int b=0;
    //1.把有可能出现异常的代码放在try中
    try
    {
        func(a,b);
    }
    catch(int)//3.接收一个int类型的异常
    {
        cout<<"除数不能为0"<<endl;
    }
}
```

#### 异常的优势

1. 异常可以抛出对象，对象可以有许多成员函数
2. 返回值可以忽略，**异常不能忽略**
3. 返回值只能返回一条信息，但对象有成员函数，可以包含多个信息
4. 逐层依赖处理异常（可以向上抛出到上一层处理）

```cpp
void test(){
catch (int)
{
    throw;
}
}
int main()
{

    try()
    {
        test();
    }
    catch(int)
    {
        cout<<"除数不能为0"<<endl;
    }
}
```

